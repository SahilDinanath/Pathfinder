<!doctype html>
<html lang="en" data-theme="retro">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <link href="/dist/output.css" rel="stylesheet" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Infinite Grid</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    #grid-container {
      display: grid;
      grid-template-columns: repeat(15, 50px);
      grid-gap: 2px;
      justify-content: center;
      padding: 10px;
    }

    .grid-item {
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }
  </style>
</head>

<body>
  <!-- speed control-->
  <div class="text-center p-5">
    <h1>Speed</h1>
  </div>
  <div class="px-20">
    <input type="range" min="0" max="100" value="40" class="range" />
  </div>

  <div class="align-middle absolute inset-y-1/3">
    <div class="p-2">
      <h1>Block Types:</h1>
    </div>
    <div class="p-2">
      <input type="radio" name="color-radio" aria-label="Start" onclick="setColor(0)" class="btn" />
    </div>
    <div class="p-2">
      <input type="radio" name="color-radio" aria-label="Wall" onclick="setColor(1)" class="btn" />
    </div>
    <div class="p-2">
      <input type="radio" name="color-radio" aria-label="Goal" onclick="setColor(2)" class="btn" />
    </div>
    <div class="p-2">
      <h1>Playback:</h1>
    </div>
    <div class="p-2">
      <button onclick="depthFirstSearch()" class="btn">Run</button>
    </div>
    <div class="p-2">
      <button onclick="reset()" class="btn">Reset</button>
    </div>
  </div>


  <div id="grid-container"></div>

  <script>
    //settings
    let color;
    let defaultColor = 'lightblue';
    let startColor = 'green'
    let wallColor = 'red'
    let goalColor = 'yellow'
    let pathColor = 'purple'
    let recursedPathColor = 'orange'
    let objectType = [startColor, wallColor, goalColor]
    let stopped = false;
    let speed = 50;

    /* UI setup */
    //grid initialisation
    const gridContainer = document.getElementById('grid-container');
    const size = 15
    const grid = new Array(size);
    for (let i = 0; i < grid.length; i++) {
      grid[i] = new Array(size);
    }

    //current color selection
    function setColor(c) {
      color = objectType[c];
    }

    //creates cell
    function createGridItem() {
      const gridItem = document.createElement('div');
      gridItem.className = 'grid-item';
      //set cell to default color
      gridItem.style.backgroundColor = defaultColor;
      //toggles sets or resets color depending on color button clicked
      gridItem.addEventListener('click', () => {
        if (gridItem.style.backgroundColor != defaultColor) {
          gridItem.style.backgroundColor = defaultColor;
        }
        else {
          gridItem.style.backgroundColor = color;
        }
      })

      return gridItem;
    }

    //creates Grid
    function populateGrid(grid) {
      // Populate the grid initially
      for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
          grid[i][j] = createGridItem();
          gridContainer.appendChild(grid[i][j]);
        }
      }
    }

    function reset() {
      for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
          //set maze color to default
          grid[i][j].style.backgroundColor = defaultColor;
          //reset all matrix cells to default 0 
          matrix[i][j] = 0;

          stopped = true;
        }
      }
    }

    // Initial population of the grid
    populateGrid(grid);


    /*search algorithms*/

    //0 = empty, 1 = start position, 2 = wall, 3 = goal
    const start = 1, wall = 2, goal = 3, visited = 4;


    //creates seperate matrix to perform search algorithms on
    const matrix = new Array(size);
    for (let i = 0; i < matrix.length; i++) {
      matrix[i] = new Array(size);
    }

    const possibleMoves = [
      {x: 0, y: -1},
      {x: -1, y: 0},
      {x: 0, y: 1},
      {x: 1, y: 0},
    ];

    //convert current current grid display into uniform matrix format
    function convertGridToMatrix(matrix, grid) {
      for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
          switch (grid[i][j].style.backgroundColor) {
            case defaultColor:
              matrix[i][j] = 0;
              break;
            case startColor:
              matrix[i][j] = start;
              break;
            case wallColor:
              matrix[i][j] = wall;
              break;
            case goalColor:
              matrix[i][j] = goal;
              break;
          }
        }
      }
    }
    function findElementInMatrix(matrix, objectType) {
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[0].length; j++) {
          if (matrix[i][j] == objectType) {
            return {x: j, y: i};
          }
        }
      }
    }


    async function depthFirstSearch() {
      //when algorithm is run, stopped is reset to false
      stopped = false;

      convertGridToMatrix(matrix, grid);
      const startPosition = findElementInMatrix(matrix, start);
      const goalPosition = findElementInMatrix(matrix, goal);
      const stack = []
      stack.push(startPosition);
      while (stack.length > 0) {
        const current = stack.pop();
        //check if goal is reached
        console.log(current);
        if (matrix[current.y][current.x] == goal) {
          break;
        }

        //get all possible moves
        for (let i = 0; i < possibleMoves.length; i++) {
          const newX = current.x + possibleMoves[i].x;
          const newY = current.y + possibleMoves[i].y;
          //bounds check
          if (newX > matrix[0].length - 1 || newX < 0) {
            continue;
          }
          if (newY > matrix.length - 1 || newY < 0) {
            continue;
          }

          //wallCheck
          if (matrix[newY][newX] == wall) {
            continue;
          }

          if (matrix[newY][newX] == visited) {
            //visualize visited cells
            grid[current.y][current.x].style.backgroundColor = recursedPathColor;
            continue;
          }

          //if all conditions are satisfied
          stack.push({x: newX, y: newY})

        }

        matrix[current.y][current.x] = visited;
        //timeout slows down algorithm so users can see it 
        await new Promise(r => setTimeout(r, speed));

        //checks to see if algorithm was aborted before updating the color of the cell
        if (stopped) {
          return;
        }

        //renders path 
        grid[current.y][current.x].style.backgroundColor = pathColor;

      }
    }
  </script>
</body>

</html>
